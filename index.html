<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Автономный портрет с ИИ</title>
<style>
body { font-family: sans-serif; margin: 2rem; }
input, button, select, textarea { margin: 0.5rem 0; padding: 0.5rem; }
.box { background: #f9f9f9; padding: 1rem; margin-top: 1rem; border-radius: 8px; }
</style>
</head>
<body>
<h1>Автономный портрет с ИИ</h1>

<label>Выберите портрет:</label>
<select id="portraitSelect"></select>
<input type="text" id="newPortrait" placeholder="Имя нового портрета">
<button id="addPortrait">Добавить портрет</button>
<button id="clearMemory">Очистить память</button><br>

<textarea id="userInput" placeholder="Введите сообщение" rows="2" cols="50"></textarea><br>
<button id="send">Отправить</button>
<button id="train">Train (добавить в память)</button><br>

<div class="box">
  <strong>Диалог:</strong>
  <div id="dialog" style="min-height:120px;"></div>
</div>

<script>
// N-грамма для генерации
class NGram {
  constructor(n=3){this.n=n;this.model={}}
  train(text){const t=text.split(/\s+/).filter(Boolean);for(let i=0;i<=t.length-this.n;i++){const k=t.slice(i,i+this.n-1).join("\u0001"),v=t[i+this.n-1];if(!this.model[k])this.model[k]={};this.model[k][v]=(this.model[k][v]||0)+1}}
  generate(maxWords=40){const keys=Object.keys(this.model);if(!keys.length)return"Я пока не знаю, что сказать...";let key=keys[Math.floor(Math.random()*keys.length)];let words=key.split("\u0001");for(let i=0;i<maxWords;i++){const dist=this.model[key];if(!dist)break;const next=weightedChoice(dist);words.push(next);key=words.slice(words.length-this.n+1).join("\u0001")}return words.join(" ")}
}
function weightedChoice(d){const total=Object.values(d).reduce((a,b)=>a+b,0);let r=Math.random()*total;for(let [w,c] of Object.entries(d)){r-=c;if(r<=0)return w}return Object.keys(d)[0]}

// Портреты и ИИ
const portraits={},portraitSelect=document.getElementById("portraitSelect"),dialogBox=document.getElementById("dialog");

// Обновление списка портретов
function updatePortraitSelect(){
  portraitSelect.innerHTML="";
  Object.keys(portraits).forEach(name=>{
    const opt=document.createElement("option");
    opt.value=name; opt.textContent=`${name} (тем: ${Object.keys(portraits[name].memory).length})`;
    portraitSelect.appendChild(opt);
  });
}

// Добавление портрета
document.getElementById("addPortrait").onclick=()=>{
  const name=document.getElementById("newPortrait").value.trim();
  if(!name) return alert("Введите имя портрета");
  if(portraits[name]) return alert("Портрет уже существует");
  portraits[name]={memory:{}, generator:new NGram(3)};
  updatePortraitSelect();
  alert(`Портрет "${name}" добавлен`);
  document.getElementById("newPortrait").value="";
};

// Автономное решение ИИ
function AIRespond(portrait, message){
  const words = message.toLowerCase().split(/\s+/);

  // 1. Найти тему с наибольшим пересечением слов
  let bestTheme=null, maxOverlap=0;
  for(const [theme, phrases] of Object.entries(portrait.memory)){
    for(const phrase of phrases){
      const overlap = phrase.toLowerCase().split(/\s+/).filter(w => words.includes(w)).length;
      if(overlap > maxOverlap){
        maxOverlap = overlap;
        bestTheme = theme;
      }
    }
  }
  // 2. Если тема не найдена, создаём новую
  const theme = bestTheme || "новая_тема_" + Object.keys(portrait.memory).length;
  if(!portrait.memory[theme]) portrait.memory[theme]=[];

  // 3. Если есть подходящая фраза в теме → выбрать случайно
  if(portrait.memory[theme].length>0){
    return portrait.memory[theme][Math.floor(Math.random()*portrait.memory[theme].length)];
  } else {
    // 4. Иначе генерация через n-грамму
    const tempGen = new NGram(3);
    Object.keys(portrait.generator.model).forEach(k=>{tempGen.model[k]={...portrait.generator.model[k]}});
    Object.values(portrait.memory).flat().forEach(msg=>tempGen.train(msg));
    return tempGen.generate();
  }
}

// Отправка сообщения
document.getElementById("send").onclick=()=>{
  const userText=document.getElementById("userInput").value.trim();
  if(!userText) return;
  const portraitName=portraitSelect.value;
  if(!portraitName) return alert("Выберите портрет");

  appendDialog(`Вы: ${userText}`);
  const portrait=portraits[portraitName];

  const reply = AIRespond(portrait, userText);

  appendDialog(`${portraitName}: ${reply}`);
  speak(reply);

  document.getElementById("userInput").value="";
};

// Train: ИИ сам решает тему
document.getElementById("train").onclick=()=>{
  const userText=document.getElementById("userInput").value.trim();
  const portraitName=portraitSelect.value;
  if(!userText) return alert("Введите сообщение для обучения");
  if(!portraitName) return alert("Выберите портрет");

  const portrait=portraits[portraitName];
  const words = userText.toLowerCase().split(/\s+/);

  // ИИ решает тему
  let bestTheme=null, maxOverlap=0;
  for(const [theme, phrases] of Object.entries(portrait.memory)){
    for(const phrase of phrases){
      const overlap = phrase.toLowerCase().split(/\s+/).filter(w => words.includes(w)).length;
      if(overlap > maxOverlap){
        maxOverlap = overlap;
        bestTheme = theme;
      }
    }
  }
  const theme = bestTheme || "новая_тема_" + Object.keys(portrait.memory).length;
  if(!portrait.memory[theme]) portrait.memory[theme]=[];
  portrait.memory[theme].push(userText);
  portrait.generator.train(userText);

  updatePortraitSelect();
  alert(`Фраза добавлена в тему "${theme}"`);
  document.getElementById("userInput").value="";
};

// Очистка памяти
document.getElementById("clearMemory").onclick=()=>{
  const portraitName=portraitSelect.value;
  if(!portraitName) return alert("Выберите портрет");
  portraits[portraitName].memory={};
  portraits[portraitName].generator=new NGram(3);
  alert("Память портрета очищена");
};

// Диалог
function appendDialog(text){
  dialogBox.innerHTML+=`<div>${text}</div>`;
  dialogBox.scrollTop=dialogBox.scrollHeight;
}

// Голос портрета
function speak(text){
  if(!window.speechSynthesis) return;
  const utter=new SpeechSynthesisUtterance(text);
  utter.lang="ru-RU";
  speechSynthesis.cancel();
  speechSynthesis.speak(utter);
}
</script>
</body>
</html>
