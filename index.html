<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Автономный ИИ-Портрет без ключа</title>
<style>
body { font-family: sans-serif; margin: 2rem; }
textarea,input,button { margin:0.5rem 0; padding:0.5rem; }
.box { background:#f9f9f9; padding:1rem; margin-top:1rem; border-radius:8px; }
</style>
</head>
<body>
<h1>ИИ-Портрет</h1>

<label>Портрет:</label>
<select id="portraitSelect"></select>
<input type="text" id="newPortrait" placeholder="Имя нового портрета">
<button id="addPortrait">Добавить</button>
<button id="clearMemory">Очистить память</button><br>

<textarea id="userInput" placeholder="Введите сообщение" rows="2" cols="50"></textarea><br>
<button id="send">Отправить</button>
<button id="train">Train</button><br>

<div class="box">
  <strong>Диалог:</strong>
  <div id="dialog" style="min-height:120px;"></div>
</div>

<script>
// N-грамма для генерации текста
class NGram {
  constructor(n=2){this.n=n;this.model={}}
  train(text){
    const words=text.split(/\s+/);
    for(let i=0;i<=words.length-this.n;i++){
      const key=words.slice(i,i+this.n-1).join(' ');
      const next=words[i+this.n-1];
      if(!this.model[key]) this.model[key]={};
      this.model[key][next]=(this.model[key][next]||0)+1;
    }
  }
  generate(max=20){
    const keys=Object.keys(this.model);
    if(!keys.length) return "Я пока ничего не знаю...";
    let key=keys[Math.floor(Math.random()*keys.length)];
    const words=key.split(' ');
    for(let i=0;i<max;i++){
      const dist=this.model[key];
      if(!dist) break;
      const next=weightedChoice(dist);
      words.push(next);
      key=words.slice(words.length-this.n+1).join(' ');
    }
    return words.join(' ');
  }
}
function weightedChoice(d){
  let sum=0;
  Object.values(d).forEach(v=>sum+=v);
  let r=Math.random()*sum;
  for(let k in d){
    r-=d[k];
    if(r<=0) return k;
  }
  return Object.keys(d)[0];
}

// Базовые знания ИИ
const defaultMemory = {
  "приветствия":["Привет!","Здравствуйте!","Рад вас видеть!"],
  "прощания":["До свидания!","Пока!","Увидимся!"],
  "шутки":["Почему утка пересекла дорогу? Чтобы попасть на другую сторону!"],
  "факты":["Солнце — это звезда.","Вода замерзает при 0°C."],
  "советы":["Отдыхайте 7–8 часов в день.","Пейте больше воды."]
};

const portraits={},portraitSelect=document.getElementById("portraitSelect"),dialogBox=document.getElementById("dialog");

// Обновление списка портретов
function updatePortraitSelect(){
  portraitSelect.innerHTML="";
  Object.keys(portraits).forEach(name=>{
    const opt=document.createElement("option");
    opt.value=name; opt.textContent=`${name} (тем: ${Object.keys(portraits[name].memory).length})`;
    portraitSelect.appendChild(opt);
  });
}

// Добавление портрета
document.getElementById("addPortrait").onclick=()=>{
  const name=document.getElementById("newPortrait").value.trim();
  if(!name) return alert("Введите имя портрета");
  if(portraits[name]) return alert("Портрет уже существует");
  portraits[name]={memory:JSON.parse(JSON.stringify(defaultMemory)), generator:new NGram(2)};
  // Обучаем генератор базовыми знаниями
  Object.values(portraits[name].memory).flat().forEach(txt=>portraits[name].generator.train(txt));
  updatePortraitSelect();
  alert(`Портрет "${name}" добавлен`);
  document.getElementById("newPortrait").value="";
};

// ИИ формирует ответ автономно
function AIRespond(portrait,message){
  const words=message.toLowerCase().split(/\s+/);
  let bestTheme=null,maxOverlap=0;
  for(const [theme,phrases] of Object.entries(portrait.memory)){
    for(const phrase of phrases){
      const overlap = phrase.toLowerCase().split(/\s+/).filter(w=>words.includes(w)).length;
      if(overlap>maxOverlap){ maxOverlap=overlap; bestTheme=theme; }
    }
  }
  const theme=bestTheme || "новая_тема_"+Object.keys(portrait.memory).length;
  if(!portrait.memory[theme]) portrait.memory[theme]=[];

  // Сначала пользовательские фразы, потом базовые
  if(portrait.memory[theme].length>0){
    return portrait.memory[theme][Math.floor(Math.random()*portrait.memory[theme].length)];
  } else {
    // Генерация
    const tempGen=new NGram(2);
    Object.keys(portrait.generator.model).forEach(k=>tempGen.model[k]={...portrait.generator.model[k]});
    Object.values(portrait.memory).flat().forEach(txt=>tempGen.train(txt));
    return tempGen.generate();
  }
}

// Отправка сообщения
document.getElementById("send").onclick=()=>{
  const userText=document.getElementById("userInput").value.trim();
  if(!userText) return;
  const name=portraitSelect.value;
  if(!name) return alert("Выберите портрет");
  appendDialog(`Вы: ${userText}`);
  const portrait=portraits[name];
  const reply=AIRespond(portrait,userText);
  appendDialog(`${name}: ${reply}`);
  speak(reply);
  document.getElementById("userInput").value="";
};

// Train — добавление новой фразы
document.getElementById("train").onclick=()=>{
  const userText=document.getElementById("userInput").value.trim();
  const name=portraitSelect.value;
  if(!userText) return alert("Введите сообщение для обучения");
  if(!name) return alert("Выберите портрет");
  const portrait=portraits[name];
  const words=userText.toLowerCase().split(/\s+/);

  // ИИ сам определяет тему
  let bestTheme=null,maxOverlap=0;
  for(const [theme,phrases] of Object.entries(portrait.memory)){
    for(const phrase of phrases){
      const overlap = phrase.toLowerCase().split(/\s+/).filter(w=>words.includes(w)).length;
      if(overlap>maxOverlap){ maxOverlap=overlap; bestTheme=theme; }
    }
  }
  const theme=bestTheme || "новая_тема_"+Object.keys(portrait.memory).length;
  if(!portrait.memory[theme]) portrait.memory[theme]=[];
  portrait.memory[theme].push(userText);
  portrait.generator.train(userText);
  updatePortraitSelect();
  alert(`Фраза добавлена в тему "${theme}"`);
  document.getElementById("userInput").value="";
};

// Очистка памяти
document.getElementById("clearMemory").onclick=()=>{
  const name=portraitSelect.value;
  if(!name) return alert("Выберите портрет");
  portraits[name].memory=JSON.parse(JSON.stringify(defaultMemory));
  portraits[name].generator=new NGram(2);
  Object.values(portraits[name].memory).flat().forEach(txt=>portraits[name].generator.train(txt));
  alert("Память портрета очищена");
};

// Диалог
function appendDialog(text){
  dialogBox.innerHTML+=`<div>${text}</div>`;
  dialogBox.scrollTop=dialogBox.scrollHeight;
}

// Голос
function speak(text){
  if(!window.speechSynthesis) return;
  const utter=new SpeechSynthesisUtterance(text);
  utter.lang="ru-RU";
  speechSynthesis.cancel();
  speechSynthesis.speak(utter);
}
</script>
</body>
</html>
